# A simple way to create SQL unit testing

= Introduction =

<wiki:toc max_depth="3" />

There is no standard framework for SQL unit testing. By "SQL unit testing" I mean testing the SQL server code being developed: SP (stored procedures) and UDF (user defined functions). 
The most common method is to use the client framework, for instance: JUnit for Java and JDBC, [http://docs.python.org/2/library/unittest.html PyUnit] for Python and C/C++ framework (like [http://code.google.com/p/googletest/ googletest] for ODBC client.
There is nothing wrong with that but any time it requires a lot of manual coding, even for the simple test scenario. So I decided to create my own simple SQL unit test framework. The purpose is to provide some method for running and executing SQL test scenario without coding. 

= General description =
The SQLTester is a plugin for BoaTester. BoaTester is a general framework for supervising the whole testing process, SQLTester is only the way of executing one (or more) test cases.
As a method for connecting and executing SQL I chose the [http://code.google.com/p/pyodbc/ pyodbc]. So before running any test ODBC connection should be set and valid and also pyodbc package should be installed.
Test scenario (execution steps and validation points) is described in a text file. The file is divided into "sections" (marked by [section] line at the beginning). Every "section" describes a sequence of test steps. A line in section contains one step. There are three types of lines:
 * Line (also several lines) containing SQL statement to execute, also stored procedure invocation.
 * Validation. Validation contains SQL SELECT statement to execute and check that columns contains expected value (also NULL and NOT NULL). So "validation" is based on checking that (result set or table) rows contain desired value. 
 * Comment
 * Calling another section.

Executing test case means executing line after line of test section content. "Test passed" means that the test case has been executed to the last line without any sql exception not caught and all validation points passed. 

= Simple example =
Let's consider a very simple test case scenario. 
 # Create MESS table with one M VARCHAR(100) column
 # Add two rows
 # Check that table MESS contains two rows

{{{
[test1]
sqlexception: CREATE TABLE MESS (M VARCHAR(100))
sql: DELETE FROM MESS
sql: INSERT INTO MESS VALUES('aaaa')
sql: INSERT INTO MESS VALUES('bbbb')
verify: SELECT COUNT(*) AS C FROM MESS
equal C 2
}}}

'sqlexception' means that SQLTester should caught sql execption thrown by sql statement. In this example the exception is expected because table MESS could exist already. It is possible to ignore all exceptions (like this example) or ignore only one expected sql code. 

= Another simple example ==
As above but check that table contains two rows with not NULL values and there is not third row.
{{{
[test2]
sqlexception(42S01): CREATE TABLE MESS (M VARCHAR(100))
sql: DELETE FROM MESS
sql: INSERT INTO MESS VALUES('aaaa')
sql: INSERT INTO MESS VALUES('bbbb')
verify: SELECT * FROM MESS ORDER BY M
isnotnull M
equal M bbbb
eof
}}}

In this example SQLTester ignores only 42S01 sql code, any other sql code will fail the test. Unfortunately, this code describing that table already exists is specific for DB2 and can be not valid for any other database.
Lines after *verify* are related to rows consecutively fetched from result set. The command *eof* means that no more row is expected at that moment.