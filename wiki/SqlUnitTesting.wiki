# A simple way to create SQL unit testing

= Introduction =

<wiki:toc max_depth="3" />

There is no standard framework for SQL unit testing. By "SQL unit testing" I mean testing the SQL server code being developed: SP (stored procedures) and UDF (user defined functions). 
The most common method is to use the client framework, for instance: JUnit for Java and JDBC, [http://docs.python.org/2/library/unittest.html PyUnit] for Python and C/C++ framework (like [http://code.google.com/p/googletest/ googletest] for ODBC client.
There is nothing wrong with that but any time it requires a lot of manual coding, even for the simple test scenario. So I decided to create my own simple SQL unit test framework. The purpose is to provide some method for running and executing SQL test scenario without coding. 

= General description =
The SQLTester is a plugin for BoaTester. BoaTester is a general framework for supervising the whole testing process, SQLTester is only the way of executing one (or more) test cases.
As a method for connecting and executing SQL I chose the [http://code.google.com/p/pyodbc/ pyodbc]. So before running any test ODBC connection should be set and valid and also pyodbc package should be installed.
Test scenario (execution steps and validation points) is described in a text file. The file is divided into "sections" (marked by [section] line at the beginning). Every "section" describes a sequence of test steps. A line in section contains one step. There are three types of lines:
 * Line (also several lines) containing SQL statement to execute, also stored procedure invocation.
 * Validation. Validation contains SQL SELECT statement to execute and check that columns contains expected value (also NULL and NOT NULL). So "validation" is based on checking that (result set or table) rows contain desired value. 
 * Comment
 * Calling another section.

Executing test case means executing line after line of test section content. "Test passed" means that the test case has been executed to the last line without any sql exception not caught and all validation points passed. 

= Simple example =
Let's consider a very simple test case scenario. 
 # Create MESS table with one M VARCHAR(100) column
 # Add two rows
 # Check that table MESS contains two rows

{{{
[test1]
sqlexception: CREATE TABLE MESS (M VARCHAR(100))
sql: DELETE FROM MESS
sql: INSERT INTO MESS VALUES('aaaa')
sql: INSERT INTO MESS VALUES('bbbb')
verify: SELECT COUNT(*) AS C FROM MESS
equal C 2
}}}

'sqlexception' means that SQLTester should caught sql execption thrown by sql statement. In this example the exception is expected because table MESS could exist already. It is possible to ignore all exceptions (like this example) or ignore only one expected sql code. 

= Another simple example ==
As above but check that table contains two rows with not NULL values and there is not third row.
{{{
[test2]
sqlexception(42S01): CREATE TABLE MESS (M VARCHAR(100))
sql: DELETE FROM MESS
sql: INSERT INTO MESS VALUES('aaaa')
sql: INSERT INTO MESS VALUES('bbbb')
verify: SELECT * FROM MESS ORDER BY M
isnotnull M
equal M bbbb
eof
}}}

In this example SQLTester ignores only 42S01 sql code, any other sql code will fail the test. Unfortunately, this code describing that table already exists is specific for DB2 and can be not valid for any other database.
Lines after *verify* are related to rows consecutively fetched from the result set. The command *eof* means that no more rows are expected at that moment or the test fails otherwise.

= Stored procedure =
== Invocation ==
The purpose of SQLTester is not to verify the correctness of database SQL engine but to test stored procedure created by a developer.
SQLTester (like pyodbc/ODBC) supports ODBC call escape format ([http://code.google.com/p/pyodbc/wiki/StoredProcedures] and vendor specific (DB2 in this example) calling clause.

{{{
[setup]
sql: CREATE OR REPLACE PROCEDURE COUNTMESS(OUT C INTEGER)
P1: BEGIN ATOMIC
  SELECT COUNT(*) INTO C FROM MESS;
 END P1
}}} 

{{{
[test3]
sql: DELETE FROM MESS
sql: { CALL LOGMESS('Next successfull step') }
sql: CALL LOGMESS('Another method') 
verify: SELECT * FROM MESS
isnotnull M
isnotnull M
eof
}}}
== OUT parameters ==
Unfortunately, neither SQLTester nor pyodbc does not support direct getting and testing OUT parameter value.
The only way is to enclose stored procedure returning value via OUT parameter by some code (often vendor specific), put this value to a staging table and and check the row in this table using method described above.
{{{
[setup]
sql: CREATE OR REPLACE PROCEDURE COUNTMESS(OUT C INTEGER)
P1: BEGIN ATOMIC
  SELECT COUNT(*) INTO C FROM MESS;
 END P1
}}}
{{{
[test4]
calltest: test3
sqlexception: CREATE TABLE PROCRESTABLE (RES1 BIGINT)
sql: BEGIN ATOMIC
 DECLARE C INTEGER;
 CALL COUNTMESS(C);
 DELETE FROM PROCRESTABLE;
 INSERT INTO PROCRESTABLE VALUES(C);
END
verify: SELECT * FROM PROCRESTABLE
equal RES1 2
eof
}}}
== Exception signalling ==
Stored procedure (like any other SQL statements) sometimes throws an exception (sql error code). Sometimes it is expected sometimes not. There are three possible choices.
 * Stored procedure should executed without any exception (most cases). Any exception should fail the test.
 * Ignore exceptions (all or one particular) if it has been thrown. Typical example is CREATE TABLE  clause where it is expected that TABLE exists already.
 * Exception is required and fail the test if it is not thrown.
{{{
[setup]
sql: CREATE OR REPLACE PROCEDURE THROWSIGNAL (IN MESS VARCHAR(100))
P1: BEGIN
    IF MESS IS NULL THEN RETURN; END IF;
    SIGNAL SQLSTATE '75000' 
             SET MESSAGE_TEXT = MESS;
END P1
}}}
{{{
sql: CALL THROWSIGNAL(NULL); 
sqlexception(75000): CALL THROWSIGNAL('Terrible error');
sqlexception(75000): CALL THROWSIGNAL(NULL);
sqlexceptionexpected(75000): CALL THROWSIGNAL('Terrible error');
print: This test should fail 
sqlexceptionexpected(75000): CALL THROWSIGNAL(NULL);
}}}
This simple example covers all cases. The last test will fail because the exception is required here.
*Warning* Unfortunately, ODBC call sequence format ( {CALL THROWSIGNAL(NULL); ) does not pass sql error codes. So if sql error detection matters one should use vendor specific stored procedure calling clause.
== UDF User Defined Functions ==
The same problem related to OUT parameters for stored procedure address also testing UDF. There is no way to get and test the return value of the UDF but we can use staging table for passing the values.
{{{
[setup]
sql: CREATE OR REPLACE FUNCTION ADDNUMBER(IN N1 INTEGER, IN N2 INTEGER) 
  RETURNS INTEGER
P1: BEGIN
  RETURN N1 + N2;
END
}}}
{{{
[test6]
--it does not work
--sql: { ? = CALL ADDNUMBER(5,4); }
sql: BEGIN
  DECLARE SUM INTEGER;
  DELETE FROM PROCRESTABLE;
  SET SUM = ADDNUMBER(4,5);
  INSERT INTO PROCRESTABLE VALUES(SUM);
  INSERT INTO PROCRESTABLE VALUES(ADDNUMBER(2,2));
END
verify: SELECT * FROM PROCRESTABLE ORDER BY RES1
equal RES1 4
equal RES1 9
eof
}}}
So we are very happy that 2+2=4 holds true also in database world.
= Parameter markers =
Sometimes it is convenient to use parameter markers instead of hardcoded values. Although the main advantage of prepared statements - prepare once and then reuse it any times thus improving performance - is not consumed here.
{{{
[test7]
sql: DELETE FROM MESS
sql(new\ message): INSERT INTO MESS VALUES(?)
sql: DELETE FROM TEST2
sql(2012-02-03): INSERT INTO TEST2 VALUES(?)
sql(next\ message):{ CALL LOGMESS(?) }
verify: SELECT * FROM MESS ORDER BY M
equal M new\ message
equal M next\ message
eof
}}}
There could be more than one parameter markers and values. Delimiter is a space and it is possible (like in this example) escape space inside value.
= Vendor specific =
One of the downside of a database programming is to deal with different vendor specific syntax. It matters particularly if we don't want to be limited to only the common subset of all dialects. There is no simple solution to this problem. But SQLTester provides simple solution to run the same test and to overcome some problems. 
Assume that we want to create a table with autoincrement field. SQLTester allows to define a 'dbtype' parameter and to qualify some vendor specific definitions.
{{{
dbtype=db2
#db2type=iany
}}}
{{{
[setup]
sql: CREATE TABLE PERSONID (ID BIGINT NOT NULL, PERSONCODE VARCHAR(100))
-- DB2 specific syntax
db2.sql: ALTER TABLE PERSONID ALTER COLUMN ID SET GENERATED ALWAYS AS IDENTITY
-- SQLAnywhere specific syntax
iany.sql:ALTER TABLE PERSONID ALTER ID DEFAULT AUTOINCREMENT
sql: INSERT INTO PERSONID VALUES(DEFAULT,'John Smith')
}}}
= More detailed description =